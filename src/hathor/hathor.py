import os
import numpy as np
from typing import TypedDict, Dict
from langgraph.graph import StateGraph, END

from .agents import HypothesisBrainstormer, PlotBrainstormer, Critic, IdeaCleaner, Coder, Executor

class State(TypedDict, total=False):
    """
    Contains all of the information that is saved during agentic processes. 
    """
    user_prompt: str                        # the initial user input
    hypotheses: Dict[str, str]              # e.g., {"1": "Hypothesis 1", "2": "Hypothesis 2"}
    plot_ideas: Dict[str, str]              # e.g., {"1a": "Plot idea 1a"}
    next_brainstormer: str                  # set by LLM in critic: can be "hypothesis" or "plot"
    hypotheses_suggestions: Dict[str, str]  # most recent suggestions for improving the hypotheses
    plot_suggestions: Dict[str, str]        # most recent suggestions for improving the plot ideas
    
    # coding variables
    generated_code: str                     # the Python code generated by the coder agent
    latest_error: str                       # the error returned by the latest run
    code_iteration: int                     # number of times that the coder has run


class Hathor():
    def __init__(self, llm, prompt="", recursion_limit=50):
        self.llm = llm
        self.recursion_limit = recursion_limit

        self.graph = self._get_graph()
        self.app = self.graph.compile()

        self.initial_state = {
            "user_prompt": prompt,
            "hypotheses": {},
            "plot_ideas": {},
        }

    def run(self):
        final_state = self.app.invoke(self.initial_state, config={"recursion_limit": self.recursion_limit})
        return final_state

    def _get_graph(self):
        graph = StateGraph(State)
        
        # Create all agents
        hypothesis_brainstormer = HypothesisBrainstormer(self.llm)
        plot_brainstormer = PlotBrainstormer(self.llm)
        critic = Critic(self.llm)
        cleaner = IdeaCleaner()
        coder = Coder(self.llm)
        executor = Executor()

        graph.add_node("hypothesis", hypothesis_brainstormer)
        graph.add_node("plot", plot_brainstormer)
        graph.add_node("critic", critic)
        graph.add_node("cleaner", cleaner)
        graph.add_node("coder", coder)
        graph.add_node("executor", executor)
        
        graph.set_entry_point("hypothesis")

        graph.add_edge("hypothesis", "critic")
        graph.add_edge("plot", "critic")
        graph.add_edge("critic", "cleaner")
        graph.add_edge("coder", "executor")

        def critic_router(state: State):
            hypotheses = state.get("hypotheses", {})
            plots = state.get("plot_ideas", {})

            # Count active hypothesis/plot pairs
            active_pairs = 0
            for hyp_key in hypotheses.keys():
                # check if any plots exist for this hypothesis
                for plot_key in plots.keys():
                    if plot_key.startswith(hyp_key):
                        active_pairs += 1

            if active_pairs == 1:
                print("sending to coder")
                return "coder"
            else:
                return state.get("next_brainstormer", "plot")
            
        def executor_router(state: State):
            """
            Routes based on execution success or failure.
            """
            error = state.get("latest_error")
            iteration = state.get("code_iteration", 0)
            max_iterations = 5  # Prevent infinite loops
            
            if error and iteration < max_iterations:
                # Send back to coder to fix
                return "coder"
            elif error and iteration >= max_iterations:
                # Give up after too many attempts
                print(f"Failed after {max_iterations} attempts. Last error: {error}")
                return END
            else:
                # Success!
                return END
            
        graph.add_conditional_edges("cleaner", critic_router)
        graph.add_conditional_edges("executor", executor_router)

        return graph

